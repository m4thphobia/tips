import torch
import torch.nn
device = "cuda" if torch.cuda.is_available() else "cpu"


class my_model(nn.Module):
    def __init__(self, in_features, out_features, hidden_features):
        super().__init__()
        self.layers = nn.Sequential(
            nn.Linear(in_features, hidden_features)
            nn.Linear(hidden_features, out_features)
        )
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        return self.layers(x)

model_0 = my_model().to(device)
print(next(model_0.parameters()).device)
loss_fn = nn.L1Loss()
optimizer = torch.optim.SGD(params=model_0.parameters(),
                            lr=0.01)
epochs = 1

for epoch in range(epochs):
    model_0.train()
    y_pred = model_0(X_train)
    loss = loss_fn(y_pred, y_train)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    model_0.eval()
    with torch.inference_mode():
        test_pred = model_0(X_test)
        test_loss = loss_fn(test_pred, y_test)

    if epoch % 100 == 0:
        print(f"Epoch: {epoch} | Loss: {loss} |Test: {test_loss}")

PATH = "../out/model_0.pth"
torch.save(model_0.state_dict(), PATH)

model_1 = my_model()
model_1.load_state_dict(torch.load(PATH))
model_1.to(device)

model_1.eval()
    with torch.inference_mode():
        test_pred = model_1(X_test)
        test_loss = loss_fn(test_pred, y_test)

    print(f"Epoch: {epoch} | Loss: {loss} |Test: {test_loss}")
